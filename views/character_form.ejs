<!-- views/character_form.ejs -->
<div class="character-sheet-container">
  <div class="character-sheet-header">
    <h2><%= isNew ? 'Create New Character' : 'Edit Character' %></h2>
    <% if (!isNew) { %>
      <div class="save-status" id="saveStatus">All changes saved</div>
    <% } %>
    <div class="character-actions">
      <a href="/characters" class="btn btn-secondary">Back to Characters</a>
      <% if (isNew) { %>
        <button type="submit" form="characterForm" class="btn btn-primary">Create Character</button>
      <% } %>
    </div>
  </div>
  
  <form id="characterForm" action="/characters<%= isNew ? '' : '/' + characterId %>" method="POST" class="character-sheet">
    <% if (!isNew) { %>
      <input type="hidden" name="_method" value="PUT">
    <% } %>
    
<!-- Updated Character Header Section with correctly aligned proficiency bonus -->
<div class="character-header-section">
  <!-- Character name section -->
  <div class="form-group character-name-group">
    <label for="name">Character Name</label>
    <input type="text" id="name" name="name" value="<%= character.name %>" class="autosave editable-field" data-field="name" required readonly>
  </div>
  
  <!-- Character details section with proficiency in last row -->
  <div class="details-labels-row">
    <label for="class">Class</label>
    <label for="level">Level</label>
    <label for="race">Race</label>
    <label for="background">Background</label>
    <label for="alignment">Alignment</label>
    <label class="proficiency-label">Proficiency Bonus</label>
  </div>
  
  <div class="details-fields-row">
    <input type="text" id="class" name="class" value="<%= character.class %>" class="autosave editable-field" data-field="class" readonly>
    <input type="number" id="level" name="level" value="<%= character.level %>" min="1" max="20" class="autosave editable-field" data-field="level" readonly>
    <input type="text" id="race" name="race" value="<%= character.race %>" class="autosave editable-field" data-field="race" readonly>
    <input type="text" id="background" name="background" value="<%= character.background || '' %>" class="autosave editable-field" data-field="background" readonly>
    <select id="alignment" name="alignment" class="autosave editable-field" data-field="alignment" readonly>
      <option value="" <%= !character.alignment ? 'selected' : '' %>>Select Alignment</option>
      <option value="Lawful Good" <%= character.alignment === 'Lawful Good' ? 'selected' : '' %>>Lawful Good</option>
      <option value="Neutral Good" <%= character.alignment === 'Neutral Good' ? 'selected' : '' %>>Neutral Good</option>
      <option value="Chaotic Good" <%= character.alignment === 'Chaotic Good' ? 'selected' : '' %>>Chaotic Good</option>
      <option value="Lawful Neutral" <%= character.alignment === 'Lawful Neutral' ? 'selected' : '' %>>Lawful Neutral</option>
      <option value="True Neutral" <%= character.alignment === 'True Neutral' ? 'selected' : '' %>>True Neutral</option>
      <option value="Chaotic Neutral" <%= character.alignment === 'Chaotic Neutral' ? 'selected' : '' %>>Chaotic Neutral</option>
      <option value="Lawful Evil" <%= character.alignment === 'Lawful Evil' ? 'selected' : '' %>>Lawful Evil</option>
      <option value="Neutral Evil" <%= character.alignment === 'Neutral Evil' ? 'selected' : '' %>>Neutral Evil</option>
      <option value="Chaotic Evil" <%= character.alignment === 'Chaotic Evil' ? 'selected' : '' %>>Chaotic Evil</option>
    </select>
    <div class="proficiency-display">
      <span id="proficiencyBonus">+<%= Math.floor((character.level - 1) / 4) + 2 %></span>
    </div>
  </div>
</div>


    
    <!-- Main Character Sheet Layout (3 columns) -->
    <div class="character-main-section">
      <!-- Left Column: Abilities and Skills -->
      <div class="character-column abilities-column">
        <h3>Abilities</h3>
        <div class="abilities-container">
          <% const abilities = [
            { key: 'strength', name: 'Strength' },
            { key: 'dexterity', name: 'Dexterity' },
            { key: 'constitution', name: 'Constitution' },
            { key: 'intelligence', name: 'Intelligence' },
            { key: 'wisdom', name: 'Wisdom' },
            { key: 'charisma', name: 'Charisma' }
          ]; %>
          
          <% abilities.forEach(ability => { %>
            <div class="ability-block">
              <label for="<%= ability.key %>"><%= ability.name %></label>
              <input 
                type="number" 
                id="<%= ability.key %>" 
                name="<%= ability.key %>" 
                value="<%= character.abilities[ability.key] %>" 
                min="1" 
                max="30" 
                class="ability-score autosave editable-field" 
                data-field="abilities.<%= ability.key %>"
                readonly
              >
              <div class="ability-modifier">
                <%= Math.floor((character.abilities[ability.key] - 10) / 2) >= 0 ? '+' : '' %><%= Math.floor((character.abilities[ability.key] - 10) / 2) %>
              </div>
            </div>
          <% }); %>
        </div>
        
        <h3>Skills</h3>
        <div class="skills-container" id="skillsContainer">
          <% character.skills.forEach((skill, index) => { %>
            <div class="skill-item">
              <input 
                type="checkbox" 
                id="skill_<%= index %>" 
                class="skill-proficient" 
                <%= skill.proficient ? 'checked' : '' %> 
                data-index="<%= index %>"
              >
              <span class="skill-modifier">
                <%= Math.floor((character.abilities[skill.ability] - 10) / 2) + (skill.proficient ? 2 : 0) >= 0 ? '+' : '' %><%= Math.floor((character.abilities[skill.ability] - 10) / 2) + (skill.proficient ? 2 : 0) %>
              </span>
              <span class="skill-name"><%= skill.name %></span>
              <span class="skill-ability">(<%= skill.ability.charAt(0).toUpperCase() %>)</span>
            </div>
          <% }); %>
          
          <!-- Custom Skills -->
          <% if (character.customSkills && character.customSkills.length > 0) { %>
            <% character.customSkills.forEach((skill, index) => { %>
              <div class="skill-item custom-skill">
                <input 
                  type="checkbox" 
                  id="custom_skill_<%= index %>" 
                  class="skill-proficient" 
                  <%= skill.proficient ? 'checked' : '' %> 
                  data-index="<%= index %>"
                  data-custom="true"
                >
                <span class="skill-modifier">
                  <%= Math.floor((character.abilities[skill.ability] - 10) / 2) + (skill.proficient ? 2 : 0) >= 0 ? '+' : '' %><%= Math.floor((character.abilities[skill.ability] - 10) / 2) + (skill.proficient ? 2 : 0) %>
                </span>
                <input 
                  type="text" 
                  class="custom-skill-name" 
                  value="<%= skill.name %>" 
                  data-index="<%= index %>"
                >
                <select class="custom-skill-ability" data-index="<%= index %>">
                  <% abilities.forEach(ability => { %>
                    <option value="<%= ability.key %>" <%= skill.ability === ability.key ? 'selected' : '' %>>
                      <%= ability.key.charAt(0).toUpperCase() %>
                    </option>
                  <% }); %>
                </select>
                <button type="button" class="remove-skill-btn" data-index="<%= index %>">Ã—</button>
              </div>
            <% }); %>
          <% } %>
        </div>
        
        <button type="button" id="addSkillBtn" class="btn btn-small">Add Custom Skill</button>
      </div>
      
      <!-- Middle Column: Combat Stats -->
      <div class="character-column combat-column">
        <div class="combat-stats">
          <div class="stat-block">
            <label for="armorClass">AC</label>
            <input 
              type="number" 
              id="armorClass" 
              name="armorClass" 
              value="<%= character.armorClass || 10 %>" 
              class="autosave editable-field" 
              data-field="armorClass"
              readonly
            >
          </div>
          
          <div class="stat-block">
            <label for="initiative">Initiative</label>
            <input 
              type="number" 
              id="initiative" 
              name="initiative" 
              value="<%= character.initiative || 0 %>" 
              class="autosave editable-field" 
              data-field="initiative"
              readonly
            >
          </div>
          
          <div class="stat-block">
            <label for="speed">Speed</label>
            <input 
              type="number" 
              id="speed" 
              name="speed" 
              value="<%= character.speed || 30 %>" 
              class="autosave editable-field" 
              data-field="speed"
              readonly
            >
          </div>
        </div>

        

<!-- Update this section in character_form.ejs -->
<div class="hit-points">
  <h4>Hit Points and Mana</h4>
  <div class="hp-container">
    <div class="form-group">
      <label for="maxHitPoints">Maximum HP</label>
      <input 
        type="number" 
        id="maxHitPoints" 
        name="maxHitPoints" 
        value="<%= character.hitPoints ? character.hitPoints.maximum : '' %>" 
        class="autosave editable-field" 
        data-field="hitPoints.maximum"
        readonly
      >
    </div>
    
    <div class="form-group">
      <label for="currentHitPoints">Current HP <i class="fas fa-heartbeat" style="color: #f44336; font-size: 0.8rem; vertical-align: middle;"></i></label>
      <input 
        type="number" 
        id="currentHitPoints" 
        name="currentHitPoints" 
        value="<%= character.hitPoints ? character.hitPoints.current : '' %>" 
        class="autosave editable-field" 
        data-field="hitPoints.current"
        readonly
      >
    </div>
  </div>
  
  <div class="hp-container mana-container">
    <div class="form-group">
      <label for="maxMana">Maximum Mana</label>
      <input 
        type="number" 
        id="maxMana" 
        name="maxMana" 
        value="<%= character.mana ? character.mana.maximum : '' %>" 
        class="autosave editable-field" 
        data-field="mana.maximum"
        readonly
      >
    </div>
    
    <div class="form-group">
      <label for="currentMana">Current Mana <i class="fas fa-hat-wizard" style="color: #3f51b5; font-size: 0.8rem; vertical-align: middle;"></i></label>
      <input 
        type="number" 
        id="currentMana" 
        name="currentMana" 
        value="<%= character.mana ? character.mana.current : '' %>" 
        class="autosave editable-field" 
        data-field="mana.current"
        readonly
      >
    </div>
  </div>
</div>


        
        <div class="equipment-section">
          <h4>Equipment</h4>
          <textarea 
            id="equipment" 
            name="equipment" 
            class="autosave editable-field" 
            data-field="equipment"
            readonly
          ><%= character.equipment || '' %></textarea>
        </div>
      </div>
      
      <!-- Right Column: Features and Spells -->
      <div class="character-column features-column">
        <div class="features-section">
          <h4>Features & Traits</h4>
          <textarea 
            id="features" 
            name="features" 
            class="autosave editable-field" 
            data-field="features"
            readonly
          ><%= character.features || '' %></textarea>
        </div>
        
        <div class="spells-section">
          <h4>Spells</h4>
          <textarea 
            id="spells" 
            name="spells" 
            class="autosave editable-field" 
            data-field="spells"
            readonly
          ><%= character.spells || '' %></textarea>
        </div>
      </div>
    </div>
    
    <!-- Hidden fields for storing skills data -->
    <input type="hidden" id="skills" name="skills" value="<%= JSON.stringify(character.skills) %>">
    <input type="hidden" id="customSkills" name="customSkills" value="<%= JSON.stringify(character.customSkills || []) %>">
  </form>
</div>





<script>
  document.addEventListener('DOMContentLoaded', function() {
    console.log("DOM fully loaded - initializing character sheet functionality");
    
    // Make editable fields work
    const editableFields = document.querySelectorAll('.editable-field');
    console.log(`Found ${editableFields.length} editable fields`);
    
    // Simple click handler for all editable fields
    document.addEventListener('click', function(e) {
      if (e.target.classList.contains('editable-field')) {
        console.log(`Clicked on ${e.target.id || e.target.name}`);
        e.target.removeAttribute('readonly');
        e.target.focus();
      }
    });
    
    // Simple blur handler for all editable fields
    document.addEventListener('blur', function(e) {
      if (e.target.classList.contains('editable-field')) {
        console.log(`Blur on ${e.target.id || e.target.name}`);
        e.target.setAttribute('readonly', '');
      }
    }, true); // Use capturing phase
    
    // Special handling for select elements
    document.addEventListener('mousedown', function(e) {
      if (e.target.tagName === 'SELECT' && e.target.classList.contains('editable-field') && e.target.hasAttribute('readonly')) {
        e.preventDefault();
        e.target.removeAttribute('readonly');
        setTimeout(() => e.target.focus(), 10);
      }
    });
    
    // Make sure initiative, armor class, and speed have their attributes
    ['initiative', 'armorClass', 'speed'].forEach(id => {
      const field = document.getElementById(id);
      if (field) {
        console.log(`Setting up ${id} field specifically`);
        field.setAttribute('readonly', '');
        field.dataset.field = id;
      }
    });
    
    // Auto-save functionality if this is an existing character
    let saveField; // Declare at this scope level
    if (document.getElementById('saveStatus')) {
      // Use a single change event listener on the form
      document.addEventListener('change', function(e) {
        if (e.target.classList.contains('autosave')) {
          console.log(`Value changed for ${e.target.id || e.target.name}: ${e.target.value}`);
          console.log(`Field: ${e.target.dataset.field}`);
          saveField(e.target.dataset.field, e.target.value);
        }
      });
      
      // Define saveField function
      saveField = async function(field, value) {
        if (!field) {
          console.error("Missing data-field attribute for field:", field);
          return;
        }
        
        const saveStatus = document.getElementById('saveStatus');
        console.log(`Saving field: ${field}, value: ${value}`);
        saveStatus.textContent = 'Saving...';
        saveStatus.classList.add('saving');
        
        try {
          const response = await fetch('/characters/<%= characterId %>', {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ field, value })
          });
          
          if (response.ok) {
            const result = await response.json();
            console.log("Save response:", result);
            
            saveStatus.textContent = 'All changes saved';
            saveStatus.classList.remove('saving');
            saveStatus.classList.add('saved');
            
            setTimeout(() => {
              saveStatus.classList.remove('saved');
            }, 2000);
          } else {
            throw new Error('Failed to save');
          }
        } catch (error) {
          console.error("Error saving:", error);
          saveStatus.textContent = 'Error saving changes';
          saveStatus.classList.remove('saving');
          saveStatus.classList.add('error');
          
          setTimeout(() => {
            saveStatus.classList.remove('error');
          }, 3000);
        }
      };
    }
    
    // Skills functionality
    const skillsContainer = document.getElementById('skillsContainer');
    const skillsInput = document.getElementById('skills');
    const customSkillsInput = document.getElementById('customSkills');
    const addSkillBtn = document.getElementById('addSkillBtn');
    
    // Initialize skills data
    let skills = JSON.parse(skillsInput.value);
    let customSkills = JSON.parse(customSkillsInput.value);
    
    // Flag to track if we're currently editing a skill
    let isEditingSkill = false;
    let currentEditingElements = []; // Track elements involved in current edit
    
    function renderAllSkills() {
      // First, clear all existing skills
      while (skillsContainer.firstChild) {
        skillsContainer.removeChild(skillsContainer.firstChild);
      }
      
      // Combine both standard and custom skills into one array
      const allSkills = [
        ...skills.map((skill, index) => ({
          ...skill,
          isCustom: false,
          originalIndex: index
        })),
        ...customSkills.map((skill, index) => ({
          ...skill,
          isCustom: true,
          originalIndex: index
        }))
      ];
      
      // Sort by name alphabetically
      allSkills.sort((a, b) => a.name.localeCompare(b.name));
      
      // Render all skills
      allSkills.forEach(skill => {
        const skillItem = document.createElement('div');
        skillItem.className = 'skill-item';
        
        // Calculate ability modifier and proficiency bonus
        const abilityMod = Math.floor((Number(document.getElementById(skill.ability).value) - 10) / 2);
        const level = parseInt(document.getElementById('level').value);
        const profBonus = Math.floor((level - 1) / 4) + 2;
        const totalMod = abilityMod + (skill.proficient ? profBonus : 0);
        
        if (skill.isCustom) {
          // Custom skill content - remove delete button from initial render
          skillItem.innerHTML = `
            <input 
              type="checkbox" 
              id="custom_skill_${skill.originalIndex}" 
              class="skill-proficient" 
              ${skill.proficient ? 'checked' : ''} 
              data-index="${skill.originalIndex}"
              data-custom="true"
            >
            <span class="skill-modifier">
              ${totalMod >= 0 ? '+' : ''}${totalMod}
            </span>
            <span class="skill-name">${skill.name}</span>
            <span class="skill-ability">(${skill.ability.charAt(0).toUpperCase()})</span>
          `;
          
          // Store the index for later use
          skillItem.dataset.skillIndex = skill.originalIndex;
        } else {
          // Standard skill content
          skillItem.innerHTML = `
            <input 
              type="checkbox" 
              id="skill_${skill.originalIndex}" 
              class="skill-proficient" 
              ${skill.proficient ? 'checked' : ''} 
              data-index="${skill.originalIndex}"
            >
            <span class="skill-modifier">
              ${totalMod >= 0 ? '+' : ''}${totalMod}
            </span>
            <span class="skill-name">${skill.name}</span>
            <span class="skill-ability">(${skill.ability.charAt(0).toUpperCase()})</span>
          `;
        }
        
        skillsContainer.appendChild(skillItem);
      });
    }

    // Function to handle custom skill editing
    function setupCustomSkillEditMode() {
      document.addEventListener('dblclick', function(e) {
        // If we double-click on a custom skill name, make it editable
        if (e.target.classList.contains('skill-name') && 
            e.target.closest('.skill-item').querySelector('[data-custom="true"]')) {
          
          // Reset any existing edit mode first
          if (isEditingSkill) {
            finishEditing();
          }
          
          isEditingSkill = true;
          
          const skillItem = e.target.closest('.skill-item');
          const checkbox = skillItem.querySelector('.skill-proficient');
          const index = parseInt(checkbox.dataset.index);
          
          // Replace the skill name span with an input
          const oldSpan = e.target;
          const nameInput = document.createElement('input');
          nameInput.type = 'text';
          nameInput.value = oldSpan.textContent;
          nameInput.className = 'custom-skill-name-edit';
          nameInput.dataset.index = index;
          
          // Replace the ability span with a select
          const abilitySpan = skillItem.querySelector('.skill-ability');
          const abilityText = abilitySpan.textContent.replace(/[()]/g, '');
          const abilitySelect = document.createElement('select');
          abilitySelect.className = 'custom-skill-ability-edit';
          abilitySelect.dataset.index = index;
          
          // Add options for each ability
          const abilities = ['strength', 'dexterity', 'constitution', 'intelligence', 'wisdom', 'charisma'];
          abilities.forEach(ability => {
            const option = document.createElement('option');
            option.value = ability;
            option.textContent = ability.charAt(0).toUpperCase();
            if (customSkills[index].ability === ability) {
              option.selected = true;
            }
            abilitySelect.appendChild(option);
          });
          
          // Add delete button when in edit mode
          const deleteButton = document.createElement('button');
          deleteButton.type = 'button';
          deleteButton.className = 'remove-skill-btn';
          deleteButton.dataset.index = index;
          deleteButton.textContent = 'Ã—';
          
          // Replace elements
          oldSpan.replaceWith(nameInput);
          abilitySpan.replaceWith(abilitySelect);
          
          // Add delete button to the end of the skillItem
          skillItem.appendChild(deleteButton);
          
          // Track current editing elements
          currentEditingElements = [nameInput, abilitySelect, deleteButton];
          
          // Focus the name input
          nameInput.focus();
          
          // Add blur handler to save changes when name input loses focus
          nameInput.addEventListener('blur', function(e) {
            // Don't save immediately if we're clicking on the ability select
            if (e.relatedTarget !== abilitySelect && e.relatedTarget !== deleteButton) {
              finishEditing();
            }
          });
          
          // Add blur handler for ability select
          abilitySelect.addEventListener('blur', function(e) {
            // Don't save immediately if we're clicking on the name input or delete button
            if (e.relatedTarget !== nameInput && e.relatedTarget !== deleteButton) {
              finishEditing();
            }
          });
          
          // The change event for ability select should only update the value, not finish editing
          abilitySelect.addEventListener('change', function() {
            customSkills[index].ability = abilitySelect.value;
          });
          
          // Add an explicit save button or handle document clicks
          document.addEventListener('click', handleGlobalClick);
        }
      });
      
      function handleGlobalClick(e) {
        if (isEditingSkill) {
          // If we click outside the current editing elements
          if (!currentEditingElements.includes(e.target) && 
              !currentEditingElements.some(el => el.contains(e.target))) {
            finishEditing();
          }
        }
      }
      
      function finishEditing() {
        if (!isEditingSkill || currentEditingElements.length === 0) return;
        
        const nameInput = currentEditingElements[0];
        const abilitySelect = currentEditingElements[1];
        const index = parseInt(nameInput.dataset.index);
        
        saveCustomSkillChanges(index, nameInput, abilitySelect);
        
        // Remove our global click handler
        document.removeEventListener('click', handleGlobalClick);
        
        isEditingSkill = false;
        currentEditingElements = [];
      }
    }

    function saveCustomSkillChanges(index, nameInput, abilitySelect) {
      // Update the custom skill data
      customSkills[index].name = nameInput.value;
      customSkills[index].ability = abilitySelect.value;
      
      // Update hidden input
      customSkillsInput.value = JSON.stringify(customSkills);
      
      // Save changes if we're editing an existing character
      if (document.getElementById('saveStatus')) {
        if (typeof saveField === 'function') {
          saveField('customSkills', customSkillsInput.value);
        } else {
          const saveStatus = document.getElementById('saveStatus');
          saveStatus.textContent = 'Saving...';
          saveStatus.classList.add('saving');
          
          fetch('/characters/<%= characterId %>', {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ field: 'customSkills', value: customSkillsInput.value })
          })
          .then(response => response.json())
          .then(result => {
            saveStatus.textContent = 'All changes saved';
            saveStatus.classList.remove('saving');
            saveStatus.classList.add('saved');
            
            setTimeout(() => {
              saveStatus.classList.remove('saved');
            }, 2000);
          })
          .catch(error => {
            console.error("Error saving:", error);
            saveStatus.textContent = 'Error saving changes';
            saveStatus.classList.remove('saving');
            saveStatus.classList.add('error');
            
            setTimeout(() => {
              saveStatus.classList.remove('error');
            }, 3000);
          });
        }
      }
      
      // Re-render skills
      renderAllSkills();
    }

    // Add Custom Skill button handler
    addSkillBtn.addEventListener('click', function() {
      const newSkill = {
        name: 'New Skill',
        ability: 'dexterity',
        proficient: false
      };
      
      customSkills.push(newSkill);
      customSkillsInput.value = JSON.stringify(customSkills);
      
      // Save changes if we're editing an existing character
      if (document.getElementById('saveStatus')) {
        if (typeof saveField === 'function') {
          saveField('customSkills', customSkillsInput.value);
        } else {
          const saveStatus = document.getElementById('saveStatus');
          saveStatus.textContent = 'Saving...';
          saveStatus.classList.add('saving');
          
          fetch('/characters/<%= characterId %>', {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ field: 'customSkills', value: customSkillsInput.value })
          })
          .then(response => response.json())
          .then(result => {
            saveStatus.textContent = 'All changes saved';
            saveStatus.classList.remove('saving');
            saveStatus.classList.add('saved');
            
            setTimeout(() => {
              saveStatus.classList.remove('saved');
            }, 2000);
          })
          .catch(error => {
            console.error("Error saving:", error);
            saveStatus.textContent = 'Error saving changes';
            saveStatus.classList.remove('saving');
            saveStatus.classList.add('error');
            
            setTimeout(() => {
              saveStatus.classList.remove('error');
            }, 3000);
          });
        }
      }
      
      // Re-render skills alphabetically
      renderAllSkills();
    });

    // Skill proficiency change handler
    skillsContainer.addEventListener('change', function(e) {
      if (e.target.classList.contains('skill-proficient')) {
        const index = parseInt(e.target.dataset.index);
        const isCustom = e.target.dataset.custom === 'true';
        
        if (isCustom) {
          customSkills[index].proficient = e.target.checked;
          customSkillsInput.value = JSON.stringify(customSkills);
          
          // Save changes if we're editing an existing character
          if (document.getElementById('saveStatus')) {
            if (typeof saveField === 'function') {
              saveField('customSkills', customSkillsInput.value);
            } else {
              const saveStatus = document.getElementById('saveStatus');
              saveStatus.textContent = 'Saving...';
              saveStatus.classList.add('saving');
              
              fetch('/characters/<%= characterId %>', {
                method: 'PUT',
                headers: {
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({ field: 'customSkills', value: customSkillsInput.value })
              })
              .then(response => response.json())
              .then(result => {
                saveStatus.textContent = 'All changes saved';
                saveStatus.classList.remove('saving');
                saveStatus.classList.add('saved');
                
                setTimeout(() => {
                  saveStatus.classList.remove('saved');
                }, 2000);
              })
              .catch(error => {
                console.error("Error saving:", error);
                saveStatus.textContent = 'Error saving changes';
                saveStatus.classList.remove('saving');
                saveStatus.classList.add('error');
                
                setTimeout(() => {
                  saveStatus.classList.remove('error');
                }, 3000);
              });
            }
          }
        } else {
          skills[index].proficient = e.target.checked;
          skillsInput.value = JSON.stringify(skills);
          
          // Save changes if we're editing an existing character
          if (document.getElementById('saveStatus')) {
            if (typeof saveField === 'function') {
              saveField('skills', skillsInput.value);
            } else {
              const saveStatus = document.getElementById('saveStatus');
              saveStatus.textContent = 'Saving...';
              saveStatus.classList.add('saving');
              
              fetch('/characters/<%= characterId %>', {
                method: 'PUT',
                headers: {
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({ field: 'skills', value: skillsInput.value })
              })
              .then(response => response.json())
              .then(result => {
                saveStatus.textContent = 'All changes saved';
                saveStatus.classList.remove('saving');
                saveStatus.classList.add('saved');
                
                setTimeout(() => {
                  saveStatus.classList.remove('saved');
                }, 2000);
              })
              .catch(error => {
                console.error("Error saving:", error);
                saveStatus.textContent = 'Error saving changes';
                saveStatus.classList.remove('saving');
                saveStatus.classList.add('error');
                
                setTimeout(() => {
                  saveStatus.classList.remove('error');
                }, 3000);
              });
            }
          }
        }
        
        // Update the display without full re-render
        const skillItem = e.target.closest('.skill-item');
        const modifierSpan = skillItem.querySelector('.skill-modifier');
        
        // Get ability and calculate new modifier
        const ability = isCustom ? customSkills[index].ability : skills[index].ability;
        const abilityMod = Math.floor((Number(document.getElementById(ability).value) - 10) / 2);
        
        // Calculate proficiency bonus based on level
        const level = parseInt(document.getElementById('level').value);
        const profBonus = Math.floor((level - 1) / 4) + 2;
        
        const totalMod = abilityMod + (e.target.checked ? profBonus : 0);
        modifierSpan.textContent = (totalMod >= 0 ? '+' : '') + totalMod;
      }
    });

    // Remove custom skill handler - only triggers when delete button is visible in edit mode
    skillsContainer.addEventListener('click', function(e) {
      if (e.target.classList.contains('remove-skill-btn')) {
        const index = parseInt(e.target.dataset.index);
        customSkills.splice(index, 1);
        customSkillsInput.value = JSON.stringify(customSkills);
        
        // Save changes if we're editing an existing character
        if (document.getElementById('saveStatus')) {
          if (typeof saveField === 'function') {
            saveField('customSkills', customSkillsInput.value);
          } else {
            const saveStatus = document.getElementById('saveStatus');
            saveStatus.textContent = 'Saving...';
            saveStatus.classList.add('saving');
            
            fetch('/characters/<%= characterId %>', {
              method: 'PUT',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({ field: 'customSkills', value: customSkillsInput.value })
            })
            .then(response => response.json())
            .then(result => {
              saveStatus.textContent = 'All changes saved';
              saveStatus.classList.remove('saving');
              saveStatus.classList.add('saved');
              
              setTimeout(() => {
                saveStatus.classList.remove('saved');
              }, 2000);
            })
            .catch(error => {
              console.error("Error saving:", error);
              saveStatus.textContent = 'Error saving changes';
              saveStatus.classList.remove('saving');
              saveStatus.classList.add('error');
              
              setTimeout(() => {
                saveStatus.classList.remove('error');
              }, 3000);
            });
          }
        }
        
        // Clear editing state
        isEditingSkill = false;
        currentEditingElements = [];
        
        // Re-render skills
        renderAllSkills();
      }
    });
    
    // Update ability modifiers when ability scores change
    const abilityInputs = document.querySelectorAll('.ability-score');
    abilityInputs.forEach(input => {
      input.addEventListener('change', function() {
        // Update the displayed modifier
        const abilityBlock = input.closest('.ability-block');
        const modifierDiv = abilityBlock.querySelector('.ability-modifier');
        const newMod = Math.floor((parseInt(input.value) - 10) / 2);
        modifierDiv.textContent = (newMod >= 0 ? '+' : '') + newMod;
        
        // Update all skills that use this ability
        const ability = input.id;
        updateSkillModifiers(ability, newMod);
      });
    });
    
    function updateSkillModifiers(ability, mod) {
      // Calculate proficiency bonus based on level
      const level = parseInt(document.getElementById('level').value);
      const profBonus = Math.floor((level - 1) / 4) + 2;
      
      // Re-render all skills since ability score changed
      renderAllSkills();
    }
    
    // Update proficiency bonus when level changes
    const levelInput = document.getElementById('level');
    const proficiencyBonusDisplay = document.getElementById('proficiencyBonus');
    
    levelInput.addEventListener('change', function() {
      const level = parseInt(this.value);
      const profBonus = Math.floor((level - 1) / 4) + 2;
      proficiencyBonusDisplay.textContent = '+' + profBonus;
      
      // Re-render all skills since proficiency bonus changed
      renderAllSkills();
    });
    
    // Initial rendering of skills
    renderAllSkills();
    setupCustomSkillEditMode();
  });


// HP Popup functionality
const currentHPInput = document.getElementById('currentHitPoints');
const maxHPInput = document.getElementById('maxHitPoints');
let hpPopup = null;
let isPopupOpen = false;

// Create the HP popup
function createHPPopup() {
  // Check if popup already exists
  if (hpPopup) {
    hpPopup.remove();
  }

  // Create popup container
  hpPopup = document.createElement('div');
  hpPopup.className = 'hp-popup';
  
  // Get the position of the current HP input
  const inputRect = currentHPInput.getBoundingClientRect();
  const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
  const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
  
  // Position the popup below the input
  hpPopup.style.position = 'absolute';
  hpPopup.style.top = (inputRect.bottom + scrollTop) + 'px';
  hpPopup.style.left = (inputRect.left + scrollLeft) + 'px';
  hpPopup.style.zIndex = '1000';
  hpPopup.style.backgroundColor = 'white';
  hpPopup.style.padding = '10px';
  hpPopup.style.borderRadius = '8px';
  hpPopup.style.boxShadow = '0 2px 10px rgba(0, 0, 0, 0.2)';
  hpPopup.style.width = '220px';
  
  // Create popup content
  hpPopup.innerHTML = `
    <div style="margin-bottom: 10px;">
      <label style="display:block; margin-bottom: 5px;">Amount:</label>
      <input type="number" id="hpChangeAmount" min="1" value="1" style="width: 100%; padding: 5px;">
    </div>
    <div style="display: flex; gap: 10px; justify-content: space-between;">
      <button id="damageBtn" style="flex: 1; padding: 8px; background-color: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer;">Damage</button>
      <button id="healBtn" style="flex: 1; padding: 8px; background-color: #4caf50; color: white; border: none; border-radius: 4px; cursor: pointer;">Healing</button>
    </div>
  `;
  
  // Add to document
  document.body.appendChild(hpPopup);
  
  // Focus on amount input
  const amountInput = document.getElementById('hpChangeAmount');
  amountInput.focus();
  
  // Add event listeners
  document.getElementById('damageBtn').addEventListener('click', applyDamage);
  document.getElementById('healBtn').addEventListener('click', applyHealing);
  
  // Close popup when clicking outside
  document.addEventListener('click', handleOutsideClick);
  
  // Allow pressing Enter to apply damage (default action)
  amountInput.addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
      applyDamage();
    }
  });
  
  isPopupOpen = true;
}

// Apply damage (subtract HP)
function applyDamage() {
  const amount = parseInt(document.getElementById('hpChangeAmount').value) || 0;
  if (amount <= 0) return;
  
  let currentHP = parseInt(currentHPInput.value) || 0;
  currentHP = Math.max(0, currentHP - amount); // Don't go below 0
  
  currentHPInput.value = currentHP;
  
  // Save the change if auto-save is enabled
  if (typeof saveField === 'function') {
    saveField('hitPoints.current', currentHP);
  }
  
  closePopup();
}

// Apply healing (add HP)
function applyHealing() {
  const amount = parseInt(document.getElementById('hpChangeAmount').value) || 0;
  if (amount <= 0) return;
  
  let currentHP = parseInt(currentHPInput.value) || 0;
  const maxHP = parseInt(maxHPInput.value) || 0;
  currentHP = Math.min(maxHP, currentHP + amount); // Don't exceed max HP
  
  currentHPInput.value = currentHP;
  
  // Save the change if auto-save is enabled
  if (typeof saveField === 'function') {
    saveField('hitPoints.current', currentHP);
  }
  
  closePopup();
}

// Close the popup
function closePopup() {
  if (hpPopup) {
    hpPopup.remove();
    hpPopup = null;
    document.removeEventListener('click', handleOutsideClick);
    isPopupOpen = false;
  }
}

// Handle clicks outside the popup to close it
function handleOutsideClick(e) {
  if (isPopupOpen && hpPopup && !hpPopup.contains(e.target) && e.target !== currentHPInput) {
    closePopup();
  }
}

// Modify the click handler for current HP
currentHPInput.addEventListener('click', function(e) {
  e.stopPropagation(); // Prevent triggering document click
  if (!isPopupOpen) {
    createHPPopup();
  }
});

// Ensure current HP remains read-only
currentHPInput.readOnly = true;

// Add a small indicator to show it's clickable
currentHPInput.style.cursor = 'pointer';
currentHPInput.title = 'Click to adjust HP';

// Add a small visual indicator next to the HP field
const hpContainer = currentHPInput.closest('.form-group');
const hpLabel = hpContainer.querySelector('label');
hpLabel.innerHTML += ' <i class="fas fa-heartbeat" style="color: #f44336; font-size: 0.8rem; vertical-align: middle;"></i>';







// Add this code to the end of your existing JavaScript in character_form.ejs
// After the HP popup code

// Mana Popup functionality
const currentManaInput = document.getElementById('currentMana');
const maxManaInput = document.getElementById('maxMana');
let manaPopup = null;
let isManaPopupOpen = false;

// Create the Mana popup
function createManaPopup() {
  // Check if popup already exists
  if (manaPopup) {
    manaPopup.remove();
  }

  // Create popup container
  manaPopup = document.createElement('div');
  manaPopup.className = 'hp-popup mana-popup';
  
  // Get the position of the current Mana input
  const inputRect = currentManaInput.getBoundingClientRect();
  const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
  const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
  
  // Position the popup below the input
  manaPopup.style.position = 'absolute';
  manaPopup.style.top = (inputRect.bottom + scrollTop) + 'px';
  manaPopup.style.left = (inputRect.left + scrollLeft) + 'px';
  manaPopup.style.zIndex = '1000';
  manaPopup.style.backgroundColor = 'white';
  manaPopup.style.padding = '10px';
  manaPopup.style.borderRadius = '8px';
  manaPopup.style.boxShadow = '0 2px 10px rgba(0, 0, 0, 0.2)';
  manaPopup.style.width = '220px';
  
  // Create popup content
  manaPopup.innerHTML = `
    <div style="margin-bottom: 10px;">
      <label style="display:block; margin-bottom: 5px;">Amount:</label>
      <input type="number" id="manaChangeAmount" min="1" value="1" style="width: 100%; padding: 5px;">
    </div>
    <div style="display: flex; gap: 10px; justify-content: space-between;">
      <button id="spendBtn" style="flex: 1; padding: 8px; background-color: #3f51b5; color: white; border: none; border-radius: 4px; cursor: pointer;">Spend</button>
      <button id="restoreBtn" style="flex: 1; padding: 8px; background-color: #2196f3; color: white; border: none; border-radius: 4px; cursor: pointer;">Restore</button>
    </div>
  `;
  
  // Add to document
  document.body.appendChild(manaPopup);
  
  // Focus on amount input
  const amountInput = document.getElementById('manaChangeAmount');
  amountInput.focus();
  
  // Add event listeners
  document.getElementById('spendBtn').addEventListener('click', spendMana);
  document.getElementById('restoreBtn').addEventListener('click', restoreMana);
  
  // Close popup when clicking outside
  document.addEventListener('click', handleManaOutsideClick);
  
  // Allow pressing Enter to spend mana (default action)
  amountInput.addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
      spendMana();
    }
  });
  
  isManaPopupOpen = true;
}

// Spend mana (subtract mana)
function spendMana() {
  const amount = parseInt(document.getElementById('manaChangeAmount').value) || 0;
  if (amount <= 0) return;
  
  let currentMana = parseInt(currentManaInput.value) || 0;
  currentMana = Math.max(0, currentMana - amount); // Don't go below 0
  
  currentManaInput.value = currentMana;
  
  // Save the change if auto-save is enabled
  if (typeof saveField === 'function') {
    saveField('mana.current', currentMana);
  }
  
  closeManaPopup();
}

// Restore mana (add mana)
function restoreMana() {
  const amount = parseInt(document.getElementById('manaChangeAmount').value) || 0;
  if (amount <= 0) return;
  
  let currentMana = parseInt(currentManaInput.value) || 0;
  const maxMana = parseInt(maxManaInput.value) || 0;
  currentMana = Math.min(maxMana, currentMana + amount); // Don't exceed max mana
  
  currentManaInput.value = currentMana;
  
  // Save the change if auto-save is enabled
  if (typeof saveField === 'function') {
    saveField('mana.current', currentMana);
  }
  
  closeManaPopup();
}

// Close the mana popup
function closeManaPopup() {
  if (manaPopup) {
    manaPopup.remove();
    manaPopup = null;
    document.removeEventListener('click', handleManaOutsideClick);
    isManaPopupOpen = false;
  }
}

// Handle clicks outside the mana popup to close it
function handleManaOutsideClick(e) {
  if (isManaPopupOpen && manaPopup && !manaPopup.contains(e.target) && e.target !== currentManaInput) {
    closeManaPopup();
  }
}

// Set up the mana fields if they exist
if (currentManaInput && maxManaInput) {
  // Modify the click handler for current mana
  currentManaInput.addEventListener('click', function(e) {
    e.stopPropagation(); // Prevent triggering document click
    if (!isManaPopupOpen) {
      createManaPopup();
    }
  });

  // Ensure current mana remains read-only
  currentManaInput.readOnly = true;

  // Add a small indicator to show it's clickable
  currentManaInput.style.cursor = 'pointer';
  currentManaInput.title = 'Click to adjust Mana';
}




</script>